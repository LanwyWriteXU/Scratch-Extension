// Name: Cyberexplorer's Toolbox
// ID: cyberexplorertoolbox
// Author: Cyberexplorer
// License: MIT

// Multi-language support

Scratch.translate.setup({
  "zh-cn": {
      "_Cyberexplorer's Toolbox": "赛博猫猫的工具箱",
      "_IndexedDB": "本地存储",
      "_store [key] as [value]": "设置键 [key] 的值为 [value]",
      "_set project description to [description]": "设置项目描述为 [description]",
      "_get value of [key]": "获取键 [key] 的值",
      "_No value found for key [key]": "未找到键 [key] 对应的值",
      "_clear storage": "清除存储空间",
      "_delete key [key]": "删除键 [key]",
      "_get number of keys": "获取键的数量",
      "_get [part] of the nth key-value pair [n]": "获取第 [n] 个键值对的 [part]",
      "_value": "值",
      "_description": "描述",
      "_key": "键",
      "_Storage cleared": "存储空间已清除",
      "_Key [key] deleted": "键 [key] 已删除",
      "_No key found": "未找到键",
      "_project description": "项目描述",
      "_Set the database name to [databaseName]": "切换数据库存储空间名称为 [databaseName]",
      "_Get current database name": "当前数据库名称",
      "_Get current database size": "当前数据库大小",
      "_Is database [databaseName] exists": "名为 [databaseName] 的数据库是否存在",
      "_Get all key-value pairs": "所有键值对",
      "_Create new database [databaseName]": "创建新数据库 [databaseName]",
      "_Delete database [databaseName]": "删除数据库 [databaseName]",
      "_Operation": "操作",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "打开 [TYPE] 类型的文件并作为 [CONTENT_TYPE] 返回",
      "_openFile": "打开文件",
      "_text": "文本",
      "_binary text": "二进制文本",
      "_DataURL": "DataURL",
      "_Color dependent": "颜色相关",
      "_convert hex color [HEX] to [FORMAT]": "将十六进制颜色 [HEX] 转换为 [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "将HSV [HUE] [SAT] [VAL] 转换为 [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "将RGB [R] [G] [B] 转换为 [FORMAT]",
      "_RGB": "RGB数组",
      "_Hexadecimal": "十六进制",
      "_Converted color": "转换后的颜色",
      "_Alert dependent": "弹窗相关",
      "_show alert [TEXT]": "显示提示 [TEXT]",
      "_confirm [TEXT]": "显示提示 [TEXT]",
      "_prompt [TEXT]": "输入提示 [TEXT]",
      "_What is your name?": "你叫什么名字？",
      "_Hello, World!": "你好，世界！",
      "_join strings": "连接字符串",
      "_add": "加法",
      "_subtract": "减法",
      "_multiply": "乘法",
      "_divide": "除法"
  },
  "ru": {
      "_Cyberexplorer's Toolbox": "Набор инструментов Cyberexplorer",
      "_IndexedDB": "Локальное хранилище",
      "_store [key] as [value]": "Установить значение ключа [key] как [value]",
      "_set project description to [description]": "Установить описание проекта как [description]",
      "_get value of [key]": "Получить значение ключа [key]",
      "_No value found for key [key]": "Не найдено значение для ключа [key]",
      "_clear storage": "Очистить хранилище",
      "_delete key [key]": "Удалить ключ [key]",
      "_get number of keys": "Получить количество ключей",
      "_get [part] of the nth key-value pair [n]": "Получить [part] n-й пары ключ-значение [n]",
      "_value": "Значение",
      "_description": "Описание",
      "_key": "Ключ",
      "_Storage cleared": "Хранилище очищено",
      "_Key [key] deleted": "Ключ [key] удален",
      "_No key found": "Не найден ключ",
      "_project description": "Описание проекта",
      "_Set the database name to [databaseName]": "Переименовать базу данных в [databaseName]",
      "_Get current database name": "Текущее имя базы данных",
      "_Get current database size": "Текущий размер базы данных",
      "_Is database [databaseName] exists": "Существует ли база данных [databaseName]",
      "_Get all key-value pairs": "Получить все пары ключ-значение",
      "_Create new database [databaseName]": "Создать новую базу данных [databaseName]",
      "_Delete database [databaseName]": "Удалить базу данных [databaseName]",
      "_Operation": "Операция",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "Открыть файл типа [TYPE] и вернуть как [CONTENT_TYPE]",
      "_openFile": "Открыть файл",
      "_text": "Текст",
      "_binary text": "Бинарный текст",
      "_DataURL": "DataURL",
      "_Color dependent": "Цветовая зависимость",
      "_convert hex color [HEX] to [FORMAT]": "Конвертировать шестнадцатеричный цвет [HEX] в формат [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "Конвертировать HSV [HUE] [SAT] [VAL] в формат [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "Конвертировать RGB [R] [G] [B] в формат [FORMAT]",
      "_RGB": "Массив RGB",
      "_Hexadecimal": "Шестнадцатеричный",
      "_Converted color": "Конвертированный цвет",
      "_Alert dependent": "Зависимость от оповещения",
      "_show alert [TEXT]": "Показать оповещение [TEXT]",
      "_confirm [TEXT]": "Подтвердить [TEXT]",
      "_prompt [TEXT]": "Запросить ввод [TEXT]",
      "_What is your name?": "Как вас зовут?",
      "_Hello, World!": "Привет, мир!",
      "_join strings": "Соединить строки",
      "_add": "Сложение",
      "_subtract": "Вычитание",
      "_multiply": "Умножение",
      "_divide": "Деление"
  },
  "ja": {
      "_Cyberexplorer's Toolbox": "サイバーエクスプローラーのツールボックス",
      "_IndexedDB": "ローカルストレージ",
      "_store [key] as [value]": "キー [key] の値を [value] に設定する",
      "_set project description to [description]": "プロジェクトの説明を [description] に設定する",
      "_get value of [key]": "キー [key] の値を取得する",
      "_No value found for key [key]": "キー [key] に対応する値が見つかりません",
      "_clear storage": "ストレージをクリアする",
      "_delete key [key]": "キー [key] を削除する",
      "_get number of keys": "キーの数を取得する",
      "_get [part] of the nth key-value pair [n]": "n番目のキー-値ペア [n] の [part] を取得する",
      "_value": "値",
      "_description": "説明",
      "_key": "キー",
      "_Storage cleared": "ストレージがクリアされました",
      "_Key [key] deleted": "キー [key] が削除されました",
      "_No key found": "キーが見つかりません",
      "_project description": "プロジェクトの説明",
      "_Set the database name to [databaseName]": "データベース名を [databaseName] に設定する",
      "_Get current database name": "現在のデータベース名を取得する",
      "_Get current database size": "現在のデータベースサイズを取得する",
      "_Is database [databaseName] exists": "データベース [databaseName] が存在するかどうか",
      "_Get all key-value pairs": "すべてのキー-値ペアを取得する",
      "_Create new database [databaseName]": "新しいデータベース [databaseName] を作成する",
      "_Delete database [databaseName]": "データベース [databaseName] を削除する",
      "_Operation": "操作",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "[TYPE] 型のファイルを開いて [CONTENT_TYPE] として返す",
      "_openFile": "ファイルを開く",
      "_text": "テキスト",
      "_binary text": "バイナリーテキスト",
      "_DataURL": "DataURL",
      "_Color dependent": "色依存",
      "_convert hex color [HEX] to [FORMAT]": "16進数の色 [HEX] を [FORMAT] に変換する",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "HSV [HUE] [SAT] [VAL] を [FORMAT] に変換する",
      "_convert RGB [R] [G] [B] to [FORMAT]": "RGB [R] [G] [B] を [FORMAT] に変換する",
      "_RGB": "RGB配列",
      "_Hexadecimal": "16進数",
      "_Converted color": "変換された色",
      "_Alert dependent": "アラート依存",
      "_show alert [TEXT]": "アラートを表示する [TEXT]",
      "_confirm [TEXT]": "確認する [TEXT]",
      "_prompt [TEXT]": "入力する [TEXT]",
      "_What is your name?": "あなたの名前は何ですか？",
      "_Hello, World!": "こんにちは、世界！",
      "_join strings": "文字列を結合する",
      "_add": "加算",
      "_subtract": "減算",
      "_multiply": "乗算",
      "_divide": "除算"
  },
  "es": {
      "_Cyberexplorer's Toolbox": "Caja de herramientas de Cyberexplorer",
      "_IndexedDB": "Almacenamiento local",
      "_store [key] as [value]": "Establecer el valor de la clave [key] como [value]",
      "_set project description to [description]": "Establecer la descripción del proyecto como [description]",
      "_get value of [key]": "Obtener el valor de la clave [key]",
      "_No value found for key [key]": "No se encontró ningún valor para la clave [key]",
      "_clear storage": "Eliminar el almacenamiento",
      "_delete key [key]": "Eliminar la clave [key]",
      "_get number of keys": "Obtener el número de claves",
      "_get [part] of the nth key-value pair [n]": "Obtener el [part] de la n-ésima pareja clave-valor [n]",
      "_value": "Valor",
      "_description": "Descripción",
      "_key": "Clave",
      "_Storage cleared": "Almacenamiento eliminado",
      "_Key [key] deleted": "Clave [key] eliminada",
      "_No key found": "No se encontró ninguna clave",
      "_project description": "Descripción del proyecto",
      "_Set the database name to [databaseName]": "Establecer el nombre de la base de datos como [databaseName]",
      "_Get current database name": "Obtener el nombre actual de la base de datos",
      "_Get current database size": "Obtener el tamaño actual de la base de datos",
      "_Is database [databaseName] exists": "¿Existe la base de datos [databaseName]?",
      "_Get all key-value pairs": "Obtener todas las parejas clave-valor",
      "_Create new database [databaseName]": "Crear una nueva base de datos [databaseName]",
      "_Delete database [databaseName]": "Eliminar la base de datos [databaseName]",
      "_Operation": "Operación",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "Abrir el archivo de [TYPE] y devolver como [CONTENT_TYPE]",
      "_openFile": "Abrir archivo",
      "_text": "Texto",
      "_binary text": "Texto binario",
      "_DataURL": "DataURL",
      "_Color dependent": "Dependiente de color",
      "_convert hex color [HEX] to [FORMAT]": "Convertir el color hexadecimal [HEX] a [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "Convertir HSV [HUE] [SAT] [VAL] a [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "Convertir RGB [R] [G] [B] a [FORMAT]",
      "_RGB": "Array RGB",
      "_Hexadecimal": "Hexadecimal",
      "_Converted color": "Color convertido",
      "_Alert dependent": "Dependiente de alerta",
      "_show alert [TEXT]": "Mostrar alerta [TEXT]",
      "_confirm [TEXT]": "Confirmar [TEXT]",
      "_prompt [TEXT]": "Solicitar entrada [TEXT]",
      "_What is your name?": "¿Cuál es tu nombre?",
      "_Hello, World!": "¡Hola, mundo!",
      "_join strings": "Unir cadenas",
      "_add": "Sumar",
      "_subtract": "Restar",
      "_multiply": "Multiplicar",
      "_divide": "Dividir"
  },
  "fr": {
      "_Cyberexplorer's Toolbox": "Boîte à outils de Cyberexplorer",
      "_IndexedDB": "Stockage local",
      "_store [key] as [value]": "Définir la valeur de la clé [key] comme [value]",
      "_set project description to [description]": "Définir la description du projet comme [description]",
      "_get value of [key]": "Obtenir la valeur de la clé [key]",
      "_No value found for key [key]": "Aucune valeur trouvée pour la clé [key]",
      "_clear storage": "Vider le stockage",
      "_delete key [key]": "Supprimer la clé [key]",
      "_get number of keys": "Obtenir le nombre de clés",
      "_get [part] of the nth key-value pair [n]": "Obtenir le [part] du n-ième couple clé-valeur [n]",
      "_value": "Valeur",
      "_description": "Description",
      "_key": "Clé",
      "_Storage cleared": "Stockage vidé",
      "_Key [key] deleted": "Clé [key] supprimée",
      "_No key found": "Aucune clé trouvée",
      "_project description": "Description du projet",
      "_Set the database name to [databaseName]": "Définir le nom de la base de données comme [databaseName]",
      "_Get current database name": "Obtenir le nom actuel de la base de données",
      "_Get current database size": "Obtenir la taille actuelle de la base de données",
      "_Is database [databaseName] exists": "Existe-t-il une base de données [databaseName]?",
      "_Get all key-value pairs": "Obtenir toutes les paires clé-valeur",
      "_Create new database [databaseName]": "Créer une nouvelle base de données [databaseName]",
      "_Delete database [databaseName]": "Supprimer la base de données [databaseName]",
      "_Operation": "Opération",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "Ouvrir le fichier de type [TYPE] et le retourner comme [CONTENT_TYPE]",
      "_openFile": "Ouvrir le fichier",
      "_text": "Texte",
      "_binary text": "Texte binaire",
      "_DataURL": "DataURL",
      "_Color dependent": "Dépendant de la couleur",
      "_convert hex color [HEX] to [FORMAT]": "Convertir la couleur hexadécimale [HEX] en [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "Convertir HSV [HUE] [SAT] [VAL] en [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "Convertir RGB [R] [G] [B] en [FORMAT]",
      "_RGB": "Tableau RGB",
      "_Hexadecimal": "Hexadécimal",
      "_Converted color": "Couleur convertie",
      "_Alert dependent": "Dépendant de l'alerte",
      "_show alert [TEXT]": "Afficher l'alerte [TEXT]",
      "_confirm [TEXT]": "Confirmer [TEXT]",
      "_prompt [TEXT]": "Demander une entrée [TEXT]",
      "_What is your name?": "Quel est votre nom?",
      "_Hello, World!": "Bonjour, monde!",
      "_join strings": "Joindre des chaînes",
      "_add": "Additionner",
      "_subtract": "Soustraire",
      "_multiply": "Multiplier",
      "_divide": "Diviser"
  },
  "zh-tw": {
      "_Cyberexplorer's Toolbox": "賽博貓貓的工具箱",
      "_IndexedDB": "本地儲存",
      "_store [key] as [value]": "將鍵 [key] 的值設置為 [value]",
      "_set project description to [description]": "將項目描述設置為 [description]",
      "_get value of [key]": "獲取鍵 [key] 的值",
      "_No value found for key [key]": "未找到鍵 [key] 對應的值",
      "_clear storage": "清除儲存空間",
      "_delete key [key]": "刪除鍵 [key]",
      "_get number of keys": "獲取鍵的數量",
      "_get [part] of the nth key-value pair [n]": "獲取第 [n] 個鍵值對的 [part]",
      "_value": "值",
      "_description": "描述",
      "_key": "鍵",
      "_Storage cleared": "儲存空間已清除",
      "_Key [key] deleted": "鍵 [key] 已刪除",
      "_No key found": "未找到鍵",
      "_project description": "項目描述",
      "_Set the database name to [databaseName]": "將資料庫名稱設置為 [databaseName]",
      "_Get current database name": "獲取當前資料庫名稱",
      "_Get current database size": "獲取當前資料庫大小",
      "_Is database [databaseName] exists": "資料庫 [databaseName] 是否存在",
      "_Get all key-value pairs": "獲取所有鍵值對",
      "_Create new database [databaseName]": "創建新資料庫 [databaseName]",
      "_Delete database [databaseName]": "刪除資料庫 [databaseName]",
      "_Operation": "操作",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "打開 [TYPE] 類型的文件並作為 [CONTENT_TYPE] 返回",
      "_openFile": "打開文件",
      "_text": "文本",
      "_binary text": "二進制文本",
      "_DataURL": "DataURL",
      "_Color dependent": "顏色相關",
      "_convert hex color [HEX] to [FORMAT]": "將十六進制顏色 [HEX] 轉換為 [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "將HSV [HUE] [SAT] [VAL] 轉換為 [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "將RGB [R] [G] [B] 轉換為 [FORMAT]",
      "_RGB": "RGB數組",
      "_Hexadecimal": "十六進制",
      "_Converted color": "轉換後的顏色",
      "_Alert dependent": "彈窗相關",
      "_show alert [TEXT]": "顯示提示 [TEXT]",
      "_confirm [TEXT]": "顯示提示 [TEXT]",
      "_prompt [TEXT]": "輸入提示 [TEXT]",
      "_What is your name?": "你叫什麼名字？",
      "_Hello, World!": "你好，世界！",
      "_join strings": "連接字串",
      "_add": "加法",
      "_subtract": "減法",
      "_multiply": "乘法",
      "_divide": "除法"
  },
  "ms": {
      "_Cyberexplorer's Toolbox": "Kotak Alat Cyberexplorer",
      "_IndexedDB": "Penyimpanan Tempatan",
      "_store [key] as [value]": "Simpan [key] sebagai [value]",
      "_set project description to [description]": "Tetapkan keterangan projek kepada [description]",
      "_get value of [key]": "Dapatkan nilai [key]",
      "_No value found for key [key]": "Tiada nilai ditemui untuk kunci [key]",
      "_clear storage": "Kosongkan penyimpanan",
      "_delete key [key]": "Padam [key]",
      "_get number of keys": "Dapatkan bilangan kunci",
      "_get [part] of the nth key-value pair [n]": "Dapatkan [part] pasangan kunci-nilai ke-n [n]",
      "_value": "Nilai",
      "_description": "Keterangan",
      "_key": "Kunci",
      "_Storage cleared": "Penyimpanan telah dikosongkan",
      "_Key [key] deleted": "Kunci [key] telah dipadam",
      "_No key found": "Tiada kunci ditemui",
      "_project description": "Keterangan projek",
      "_Set the database name to [databaseName]": "Tetapkan nama pangkalan data kepada [databaseName]",
      "_Get current database name": "Dapatkan nama pangkalan data semasa",
      "_Get current database size": "Dapatkan saiz pangkalan data semasa",
      "_Is database [databaseName] exists": "Adakah pangkalan data [databaseName] wujud",
      "_Get all key-value pairs": "Dapatkan semua pasangan kunci-nilai",
      "_Create new database [databaseName]": "Cipta pangkalan data baru [databaseName]",
      "_Delete database [databaseName]": "Padam pangkalan data [databaseName]",
      "_Operation": "Operasi",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "Buka fail [TYPE] dan kembalikan sebagai [CONTENT_TYPE]",
      "_openFile": "Buka fail",
      "_text": "Teks",
      "_binary text": "Teks binari",
      "_DataURL": "DataURL",
      "_Color dependent": "Bergantung warna",
      "_convert hex color [HEX] to [FORMAT]": "Tukar warna heksadesimal [HEX] kepada [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "Tukar HSV [HUE] [SAT] [VAL] kepada [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "Tukar RGB [R] [G] [B] kepada [FORMAT]",
      "_RGB": "Array RGB",
      "_Hexadecimal": "Heksadesimal",
      "_Converted color": "Warna yang ditukar",
      "_Alert dependent": "Bergantung alert",
      "_show alert [TEXT]": "Tunjukkan alert [TEXT]",
      "_confirm [TEXT]": "Sahkan [TEXT]",
      "_prompt [TEXT]": "Minta input [TEXT]",
      "_What is your name?": "Siapa nama kamu?",
      "_Hello, World!": "Halo, Dunia!",
      "_join strings": "Sambungkan string",
      "_add": "Tambah",
      "_subtract": "Tolak",
      "_multiply": "Darab",
      "_divide": "Bahagi"
  },
  "pt": {
      "_Cyberexplorer's Toolbox": "Caixa de Ferramentas do Cyberexplorer",
      "_IndexedDB": "Armazenamento Local",
      "_store [key] as [value]": "Armazenar [key] como [value]",
      "_set project description to [description]": "Definir descrição do projeto como [description]",
      "_get value of [key]": "Obter o valor de [key]",
      "_No value found for key [key]": "Nenhum valor encontrado para a chave [key]",
      "_clear storage": "Limpar armazenamento",
      "_delete key [key]": "Excluir chave [key]",
      "_get number of keys": "Obter número de chaves",
      "_get [part] of the nth key-value pair [n]": "Obter [part] do n-ésimo par chave-valor [n]",
      "_value": "Valor",
      "_description": "Descrição",
      "_key": "Chave",
      "_Storage cleared": "Armazenamento limpo",
      "_Key [key] deleted": "Chave [key] excluída",
      "_No key found": "Nenhuma chave encontrada",
      "_project description": "Descrição do projeto",
      "_Set the database name to [databaseName]": "Definir nome do banco de dados como [databaseName]",
      "_Get current database name": "Obter nome atual do banco de dados",
      "_Get current database size": "Obter tamanho atual do banco de dados",
      "_Is database [databaseName] exists": "O banco de dados [databaseName] existe?",
      "_Get all key-value pairs": "Obter todos os pares chave-valor",
      "_Create new database [databaseName]": "Criar um novo banco de dados [databaseName]",
      "_Delete database [databaseName]": "Excluir banco de dados [databaseName]",
      "_Operation": "Operação",
      "_Opens the file of [TYPE] and returns as [CONTENT_TYPE]": "Abrir o arquivo de [TYPE] e retornar como [CONTENT_TYPE]",
      "_openFile": "Abrir arquivo",
      "_text": "Texto",
      "_binary text": "Texto binário",
      "_DataURL": "DataURL",
      "_Color dependent": "Dependente de cor",
      "_convert hex color [HEX] to [FORMAT]": "Converter cor hexadecimal [HEX] para [FORMAT]",
      "_convert HSV [HUE] [SAT] [VAL] to [FORMAT]": "Converter HSV [HUE] [SAT] [VAL] para [FORMAT]",
      "_convert RGB [R] [G] [B] to [FORMAT]": "Converter RGB [R] [G] [B] para [FORMAT]",
      "_RGB": "Array RGB",
      "_Hexadecimal": "Hexadecimal",
      "_Converted color": "Cor convertida",
      "_Alert dependent": "Dependente de alerta",
      "_show alert [TEXT]": "Mostrar alerta [TEXT]",
      "_confirm [TEXT]": "Confirmar [TEXT]",
      "_prompt [TEXT]": "Solicitar entrada [TEXT]",
      "_What is your name?": "Qual é o seu nome?",
      "_Hello, World!": "Olá, Mundo!",
      "_join strings": "Unir strings",
      "_add": "Adicionar",
      "_subtract": "Subtrair",
      "_multiply": "Multiplicar",
      "_divide": "Dividir"
  }
});
function createJsonResponse(fileName, content, format) {
  return JSON.stringify({
    name: fileName,
    content: content,
    format: format,
  });
}

(function (Scratch) {
  "use strict";

  if (!Scratch.extensions.unsandboxed) {
    throw new Error("indexeddb extension must be run unsandboxed");
  }

  const DB_NAME = "ScratchIndexedDB";
  const DB_VERSION = 1;
  const STORE_NAME = "scratchStore";

  // Dynamic block functionality
  const { BlockType, ArgumentType } = Scratch;

  const { initExpandableBlocks, getDynamicArgs } = (() => {
    // Based on Nights/FurryR/zxq's expandable block code
    const INPUT_TYPES_OPTIONS_LABEL = {
      s: 'ADD_TEXT_PARAMETER',
      n: 'ADD_NUM_PARAMETER',
      b: 'ADD_BOOL_PARAMETER',
    };

    const leftArrow = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyNi4zMzU2MSIgaGVpZ2h0PSI0Ni42NjgzOSIgdmlld0JveD0iMCwwLDI2LjMzNTYxLDQ2LjY2ODM5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzA2LjgzMjIsLTE1Ni42NjU4KSI+PGcgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aXNQYWludGluZ0xheWVyJnF1b3Q7OnRydWV9IiBmaWxsPSIjZmZmZmZmIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6IG5vcm1hbCI+PHBhdGggZD0iTTMyOC4wNDY4LDIwMi40NTcyNWwtMjAuMzM1NSwtMjAuMzM3Yy0wLjU2Mjg3LC0wLjU2MjY0IC0wLjg3OTExLC0xLjMyNTg5IC0wLjg3OTExLC0yLjEyMTc1YzAsLTAuNzk1ODYgMC4zMTYyNCwtMS41NTkxMSAwLjg3OTExLC0yLjEyMTc1bDIwLjMzNTUsLTIwLjMzMjVjMC44NTc5OCwtMC44NTc3MiAyLjE0ODExLC0xLjExNDI3IDMuMjY4OTYsLTAuNjUwMDNjMS4xMjA4NSwwLjQ2NDIzIDEuODUxNzgsMS41NTc4NSAxLjg1MjA0LDIuNzcxMDN2NDAuNjY5NWMtMC4wMDAyNiwxLjIxMzE5IC0wLjczMTE4LDIuMzA2OCAtMS44NTIwNCwyLjc3MTAzYy0xLjEyMDg1LDAuNDY0MjMgLTIuNDEwOTgsMC4yMDc2OSAtMy4yNjg5NiwtMC42NTAwM3oiLz48L2c+PC9nPjwvc3ZnPg==';

    const rightArrow = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyNi4zMzU2MSIgaGVpZ2h0PSI0Ni42NjgzOSIgdmlld0JveD0iMCwwLDI2LjMzNTYxLDQ2LjY2ODM5Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzA2LjgzMjE5LC0xNTYuNjY1ODEpIj48ZyBkYXRhLXBhcGVyLWRhdGE9InsmcXVvdDtpc1BhaW50aW5nTGF5ZXImcXVvdDs6dHJ1ZX0iIGZpbGw9IiNmZmZmZmYiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lY2FwPSJidXR0IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTogbm9ybWFsIj48cGF0aCBkPSJNMzExLjk1MzE5LDIwMi40NTU3NWMtMC44NTc5OCwwLjg1NzcyIC0yLjE0ODExLDEuMTE0MjYgLTMuMjY4OTYsMC42NTAwM2MtMS4xMjA4NiwtMC40NjQyMyAtMS44NTE3OCwtMS41NTc4NCAtMS44NTIwNCwtMi43NzEwM3YtNDAuNjY5NWMwLjAwMDI2LC0xLjIxMzE4IDAuNzMxMTksLTIuMzA2OCAxLjg1MjA0LC0yLjc3MTAzYzEuMTIwODUsLTAuNDY0MjQgMi40MTA5OCwtMC4yMDc2OSAzLjI2ODk2LDAuNjUwMDNsMjAuMzM1NSwyMC4zMzI1YzAuNTYyODcsMC41NjI2NCAwLjg3OTExLDEuMzI1ODkgMC44NzkxMSwyLjEyMTc1YzAsMC43OTU4NiAtMC4zMTYyNCwxLjU1OTExIC0wLjg3OTExLDIuMTIxNzVsLTIwLjMzNTUsMjAuMzM3eiIgZGF0YS1wYXBlci1kYXRhPSJ7JnF1b3Q7aW5kZXgmcXVvdDs6bnVsbH0iLz48L2c+PC9nPjwvc3ZnPg==';

    const minusButton = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPSJNMzggMTFoLTEyYy0xLjEwNCAwLTIgLjg5Ni0yIDJzLjg5NiAyIDIgMmgxMmMxLjEwNCAwIDItLjg5NiAyLTJzLS44OTYtMi0yLTJ6IiBmaWxsPSJ3aGl0ZSIgLz48L3N2Zz4K';

    const plusButton = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPSJNMTggMTBoLTR2LTRjMC0xLjEwNC0uODk2LTItMi0ycy0yIC44OTYtMiAybC4wNzEgNGgtNC4wNzFjLTEuMTA0IDAtMiAuODk2LTIgMnMuODk2IDIgMiAybDQuMDcxLS4wNzEtLjA3MSA0LjA3MW' +
      'MwIDEuMTA0Ljg5NiAyIDIgMnMyLS44OTYgMi0ydi00LjA3MWw0IC4wNzFjMS4xMDQgMCAyLS' +
      '44OTYgMi0ycy0uODk2LTItMi0yeiIgZmlsbD0id2hpdGUiIC8+PC9zdmc+Cg==';

    const defaultPlusSelectImage = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTQiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA1NCAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC41IiB5PSIwLjUiIHdpZHRoPSI1MyIgaGVpZ2h0PSIzMSIgcng9IjE1LjUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1vcGFjaXR5PSIwLjIiLz4KPHBhdGggZD0iTTE3Ljk5OTggMTAuMTY0MVYyMS44MzA3TTEyLjE2NjUgMTUuOTk3NEgyMy44MzMyIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjEuNjY2NjciIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMzkuNzYzOCAxOC44Mzg2QzM5LjMyNTQgMTkuMjE4MiAzOC42NzQ2IDE5LjIxODIgMzguMjM2MiAxOC44Mzg2TDM1LjMwMzMgMTYuMjk4NkMzNC40ODY4IDE1LjU5MTQgMzQuOTg2OSAxNC4yNSAzNi4wNjcxIDE0LjI1TDQxLjkzMjkgMTQuMjVDNDMuMDEzMSAxNC4yNSA0My41MTMyIDE1LjU5MTQgNDIuNjk2NyAxNi4yOTg2TDM5Ljc2MzggMTguODM4NloiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=';

    const enabledDynamicArgBlocksInfo = {};
    const extInfo = {};

    let proxingBlocklyBlocks = false;

    function hijack(fn) {
      const _orig = Function.prototype.apply;
      Function.prototype.apply = (thisArg) => thisArg;
      const result = fn();
      Function.prototype.apply = _orig;
      return result;
    }

    function getEventListener(e) {
      return e instanceof Array ? e[e.length - 1] : e;
    }

    function getScratchBlocks(runtime) {
      return (
        runtime.scratchBlocks ||
        window.ScratchBlocks ||
        hijack(getEventListener(runtime._events.EXTENSION_ADDED))?.ScratchBlocks
      );
    }

    function setLocales(Blockly) {
      Object.assign(Blockly.ScratchMsgs.locales.en, {
        ADD_TEXT_PARAMETER: 'Add Text Parameter',
        ADD_NUM_PARAMETER: 'Add Num Parameter',
        ADD_BOOL_PARAMETER: 'Add Bool Parameter',
        DELETE_DYNAMIC_PARAMETER: 'Delete Dynamic Parameter',
      });

      Object.assign(Blockly.ScratchMsgs.locales['zh-cn'], {
        ADD_TEXT_PARAMETER: '添加文本参数',
        ADD_NUM_PARAMETER: '添加数字参数',
        ADD_BOOL_PARAMETER: '添加布尔值参数',
        DELETE_DYNAMIC_PARAMETER: '删除动态参数',
      });
    }
    //CCW l10n Format

    function translate(Blockly, key) {
      return Blockly.ScratchMsgs.translate(key);
    }

    function createButtons(Blockly, plusImage = rightArrow, minusImage = leftArrow) {
      let w = 25;
      let h = 47;
      let size = 0.35;
      if (plusImage === '+') {
        plusImage = plusButton;
        w = 18;
        h = 18;
        size = 0.7;
      }
      if (minusImage === '-') {
        minusImage = minusButton;
        w = 18;
        h = 18;
        size = 0.7;
      }
      class FieldButton extends Blockly.FieldImage {
        constructor(src, width = w * size, height = h * size) {
          super(src, width, height, undefined, false);
          this.initialized = false;
        }

        init() {
          super.init();

          if (!this.initialized) {
            this.getSvgRoot().style.cursor = 'pointer';
            Blockly.bindEventWithChecks_(this.getSvgRoot(), 'mousedown', this, (e) => {
              e.stopPropagation();
            });
            Blockly.bindEventWithChecks_(this.getSvgRoot(), 'mouseup', this, this.handleClick.bind(this));
          }
          this.initialized = true;
        }

        handleClick(e) {
          if (!this.sourceBlock_ || !this.sourceBlock_.workspace) return;
          if (this.sourceBlock_.workspace.isDragging()) return;
          if (this.sourceBlock_.isInFlyout) return;
          this.onClick(e);
        }

        onClick() {
          // Implemented by subclass
        }
      }

      class PlusSelectButton extends FieldButton {
        constructor() {
          super(defaultPlusSelectImage, 54, 32);
        }

        onClick(e) {
          const menuOptions = this.sourceBlock_.dynamicArgOptionalTypes_.map((i) => ({
            text: translate(Blockly, INPUT_TYPES_OPTIONS_LABEL[i]),
            enabled: true,
            callback: () => {
              this.sourceBlock_.addDynamicArg(i);
            },
          }));
          Blockly.ContextMenu.show(e, menuOptions, false);
        }
      }

      class PlusButton extends FieldButton {
        constructor() {
          super(plusImage);
        }

        onClick() {
          this.sourceBlock_.addDynamicArg(this.sourceBlock_.dynamicArgOptionalTypes_[0]);
        }
      }

      class MinusButton extends FieldButton {
        constructor() {
          super(minusImage);
        }

        onClick() {
          const { dynamicArgumentIds_ } = this.sourceBlock_;
          this.sourceBlock_.removeDynamicArg(dynamicArgumentIds_[dynamicArgumentIds_.length - 1]);
        }
      }

      return {
        PlusSelectButton,
        PlusButton,
        MinusButton,
      };
    }

    function proxyBlocklyBlocksObject(runtime) {
      if (proxingBlocklyBlocks) return;
      proxingBlocklyBlocks = true;
      const Blockly = getScratchBlocks(runtime);
      if (!Blockly) return;
      setLocales(Blockly);
      Blockly.Blocks = new Proxy(Blockly.Blocks, {
        set(target, opcode, blockDefinition) {
          if (Object.prototype.hasOwnProperty.call(enabledDynamicArgBlocksInfo, opcode)) {
            initExpandableBlock(runtime, blockDefinition, enabledDynamicArgBlocksInfo[opcode]);
          }
          return Reflect.set(target, opcode, blockDefinition);
        },
      });
    }

    function initExpandableBlock(runtime, blockDefinition, dynamicArgInfo) {
      const { PlusSelectButton, PlusButton, MinusButton } = dynamicArgInfo.extInfo;
      const Blockly = getScratchBlocks(runtime);

      function getValue(value, i, defaultValue, valueWhenOutOfRange) {
        if (value === undefined) return defaultValue;
        if (Array.isArray(value)) {
          if (i < value.length) return value[i];
          if (valueWhenOutOfRange !== undefined) return valueWhenOutOfRange;
          return value[value.length - 1];
        }
        return typeof value === 'function' ? value(i) : value;
      }

      function getParamsIncPerClick(i) {
        return getValue(this.dynamicArgInfo_.paramsIncrement, i, 1, 0);
      }

      function getAddClickCount(num) {
        let sum = 0;
        let i = 0;
        let inc = 0;
        while (sum < num) {
          inc = getParamsIncPerClick.call(this, i);
          if (inc === 0) throw new Error(`Unreachable param num`);
          sum += inc;
          i++;
        }
        return i;
      }

      function getParamsGroupindexes(num) {
        let sum = 0;
        let i = 0;
        let inc = 0;
        while (sum < num) {
          inc = getParamsIncPerClick.call(this, i);
          if (inc === 0) throw new Error(`Unreachable param num`);
          sum += inc;
          i++;
        }
        sum -= inc;
        return Array.from({ length: inc }, (_, j) => sum + j + 1);
      }

      function getNextParamInc() {
        return getParamsIncPerClick.call(this, getAddClickCount.call(this, this.dynamicArgumentTypes_.length));
      }

      const moveButtonToTheRightPlace = function () {
        const showPlus = getNextParamInc.call(this) > 0;
        if (showPlus) {
          this.getInput('PLUS').setVisible(true);
          const { afterArg } = this.dynamicArgInfo_;
          if (afterArg) {
            this.moveInputBefore('PLUS', afterArg);
            this.moveInputBefore(afterArg, 'PLUS');
          }
        } else {
          this.getInput('PLUS').setVisible(false);
        }
        if (this.getInput('ENDTEXT')) this.moveInputBefore('ENDTEXT', 'PLUS');
        const cnt = this.dynamicArgumentTypes_.length;
        if (cnt === 0) {
          this.removeInput('MINUS');
        } else {
          if (!this.getInput('MINUS')) this.appendDummyInput('MINUS').appendField(new MinusButton());
          this.moveInputBefore('MINUS', 'PLUS');
        }
      };

      const orgInit = blockDefinition.init;
      blockDefinition.init = function () {
        orgInit.call(this);

        this.dynamicArgumentIds_ = [];
        this.dynamicArgumentTypes_ = [];
        this.dynamicArgInfo_ = dynamicArgInfo;
        this.dynamicArgOptionalTypes_ = dynamicArgInfo.dynamicArgTypes;
        this.plusButton_ = dynamicArgInfo.dynamicArgTypes.length > 1 ? new PlusSelectButton() : new PlusButton();
        this.minusButton_ = new MinusButton();

        const { afterArg, endText } = dynamicArgInfo;
        if (!this.getInput) return;
        updatePreText(this, 0);
        const endTxt = getValue(endText, 0, '');
        if (endTxt !== '') this.appendDummyInput('ENDTEXT').appendField(endTxt, 'ENDTEXT');
        this.appendDummyInput('PLUS').appendField(this.plusButton_);
        if (afterArg) {
          const plusInput = this.getInput('PLUS');
          const endTxtInput = this.getInput('ENDTEXT');
          const afterArgInput = this.getInput(afterArg);
          const plusIndex = this.inputList.indexOf(plusInput);
          const endTxtIndex = this.inputList.indexOf(endTxtInput);
          const afterArgIndex = this.inputList.indexOf(afterArgInput);
          if (plusIndex > -1 && afterArgIndex > -1) {
            this.inputList.splice(plusIndex, 1);
            this.inputList.splice(afterArgIndex + 1, 0, plusInput);
            if (endTxtIndex > -1) {
              this.inputList.splice(endTxtIndex, 1);
              this.inputList.splice(afterArgIndex + 1, 0, endTxtInput);
            }
          }
        }
      };

      blockDefinition.customContextMenu = function (contextMenu) {
        this.dynamicArgOptionalTypes_.forEach((i) =>
          contextMenu.push({
            text: translate(Blockly, INPUT_TYPES_OPTIONS_LABEL[i]),
            enabled: true,
            callback: () => {
              this.addDynamicArg(i);
            },
          })
        );
      };

      blockDefinition.attachShadow_ = function (input, argumentType, defaultValue = '') {
        if (argumentType === 'n' || argumentType === 's') {
          const blockType = argumentType === 'n' ? 'math_number' : 'text';
          Blockly.Events.disable();
          const newBlock = this.workspace.newBlock(blockType);
          try {
            if (argumentType === 'n') {
              newBlock.setFieldValue(defaultValue, 'NUM');
            } else {
              newBlock.setFieldValue(defaultValue, 'TEXT');
            }
            newBlock.setShadow(true);
            if (!this.isInsertionMarker()) {
              newBlock.initSvg();
              newBlock.render(false);
            }
          } finally {
            Blockly.Events.enable();
          }
          if (Blockly.Events.isEnabled()) {
            Blockly.Events.fire(new Blockly.Events.BlockCreate(newBlock));
          }
          newBlock.outputConnection.connect(input.connection);
        }
      };

      blockDefinition.mutationToDom = function () {
        const container = document.createElement('mutation');
        container.setAttribute('dynamicargids', JSON.stringify(this.dynamicArgumentIds_));
        container.setAttribute('dynamicargtypes', JSON.stringify(this.dynamicArgumentTypes_));
        return container;
      };

      blockDefinition.domToMutation = function (xmlElement) {
        this.dynamicArgumentIds_ = JSON.parse(xmlElement.getAttribute('dynamicargids')) || [];
        this.dynamicArgumentTypes_ = JSON.parse(xmlElement.getAttribute('dynamicargtypes')) || [];
        this.updateDynamicDisplay_();
      };

      blockDefinition.addDynamicArg = function (type) {
        const oldMutationDom = this.mutationToDom();
        const oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom);

        Blockly.Events.setGroup(true);

        let index = 0;
        const lastArgName = this.dynamicArgumentIds_.slice(-1)[0];
        if (lastArgName) {
          [index] = lastArgName.match(/\d+/g);
        }
        index = Number(index);

        const cnt = getNextParamInc.call(this);
        for (let i = 0; i < cnt; i++) {
          this.dynamicArgumentIds_.push(`DYNAMIC_ARGS${index + i + 1}`);
          this.dynamicArgumentTypes_.push(type);
        }
        this.updateDynamicDisplay_();

        const newMutationDom = this.mutationToDom();
        const newMutation = newMutationDom && Blockly.Xml.domToText(newMutationDom);
        if (oldMutation !== newMutation) {
          Blockly.Events.fire(new Blockly.Events.BlockChange(this, 'mutation', null, oldMutation, newMutation));
        }

        Blockly.Events.setGroup(false);
      };

      blockDefinition.removeDynamicArg = function (id) {
        Blockly.Events.setGroup(true);

        const oldMutationDom = this.mutationToDom();
        const oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom);

        const matches = id.match(/^([^\d]+)(\d+)$/);
        const name = matches[1];
        const i = Number(matches[2]);
        const paramsToRemove = getParamsGroupindexes.call(this, i);
        paramsToRemove.forEach((it) => {
          const curId = `${name}${it}`;
          const idx = this.dynamicArgumentIds_.indexOf(curId);
          this.dynamicArgumentIds_.splice(idx, 1);
          this.dynamicArgumentTypes_.splice(idx, 1);
          this.removeInput(curId);
        });

        this.updateDynamicDisplay_();

        const newMutationDom = this.mutationToDom();
        const newMutation = newMutationDom && Blockly.Xml.domToText(newMutationDom);
        if (oldMutation !== newMutation) {
          Blockly.Events.fire(new Blockly.Events.BlockChange(this, 'mutation', null, oldMutation, newMutation));
          setTimeout(() => {
            const target = runtime.getEditingTarget();
            const block = target.blocks._blocks[this.id];
            Object.keys(block.inputs).forEach((name) => {
              if (/^DYNAMIC_ARGS\d+$/.test(name) && !this.dynamicArgumentIds_.includes(name)) {
                target.blocks.deleteBlock(block.inputs[name].shadow, {
                  source: 'default',
                  targetId: target.id,
                });
                delete block.inputs[name];
                if (runtime.emitTargetBlocksChanged) {
                  runtime.emitTargetBlocksChanged(target.id, ['deleteInput', { id: block.id, inputName: name }]);
                }
              }
            });
          }, 0);
        }

        Blockly.Events.setGroup(false);
      };

      blockDefinition.updateDynamicDisplay_ = function () {
        const wasRendered = this.rendered;
        this.rendered = false;

        const connectionMap = this.disconnectDynamicArgBlocks_();
        this.removeAllDynamicArgInputs_();

        this.createAllDynamicArgInputs_(connectionMap);
        this.deleteShadows_(connectionMap);

        this.rendered = wasRendered;
        if (wasRendered && !this.isInsertionMarker()) {
          this.initSvg();
          this.render();
        }
      };

      blockDefinition.disconnectDynamicArgBlocks_ = function () {
        const connectionMap = {};
        for (let i = 0; this.inputList[i]; i++) {
          const input = this.inputList[i];
          if (input.connection && /^DYNAMIC_ARGS\d+$/.test(input.name)) {
            const target = input.connection.targetBlock();
            const saveInfo = {
              shadow: input.connection.getShadowDom(),
              block: target,
            };
            connectionMap[input.name] = saveInfo;

            input.connection.setShadowDom(null);
            if (target) {
              input.connection.disconnect();
            }
          }
        }
        return connectionMap;
      };

      blockDefinition.removeAllDynamicArgInputs_ = function () {
        const inputList = [];
        for (let i = 0; this.inputList[i]; i++) {
          const input = this.inputList[i];
          if (/^DYNAMIC_ARGS\d+$/.test(input.name)) {
            input.dispose();
          } else {
            inputList.push(input);
          }
        }
        this.inputList = inputList;
      };

      function updatePreText(block, num) {
        const { preText, afterArg } = block.dynamicArgInfo_;
        if (preText) {
          const txt = getValue(preText, num, '');
          const input = afterArg
            ? block.inputList.find((i) => i.name === afterArg)
            : block.inputList.findLast((it) => it.name !== 'PLUS' && it.name !== 'MINUS' && it.name !== 'ENDTEXT');
          input.fieldRow.findLast((it) => it instanceof Blockly.FieldLabel)?.setText(txt);
        }
      }

      blockDefinition.createAllDynamicArgInputs_ = function (connectionMap) {
        const num = this.dynamicArgumentTypes_.length;
        const { endText, joinCh, afterArg } = this.dynamicArgInfo_;
        updatePreText(this, num);
        for (let i = 0; i < num; i++) {
          const argumentType = this.dynamicArgumentTypes_[i];
          if (!(argumentType === 'n' || argumentType === 'b' || argumentType === 's')) {
            throw new Error(`Found an dynamic argument with an invalid type: ${argumentType}`);
          }

          const id = this.dynamicArgumentIds_[i];
          const input = this.appendValueInput(id);
          if (joinCh && (i !== 0 || afterArg)) {
            input.appendField(getValue(joinCh, i, ''));
          }
          if (argumentType === 'b') {
            input.setCheck('Boolean');
          }
          this.populateArgument_(argumentType, connectionMap, id, input, i);
        }
        const txt = getValue(endText, num, '');
        if (txt === '') {
          this.removeInput('ENDTEXT', true);
        } else {
          const field = this.getField('ENDTEXT');
          if (field) field.setValue(txt);
          else this.appendDummyInput('ENDTEXT').appendField(txt, 'ENDTEXT');
        }
        moveButtonToTheRightPlace.call(this);
        if (afterArg) {
          const cnt = this.dynamicArgumentTypes_.length;
          for (let i = cnt - 1; i >= 0; i--) {
            const id = this.dynamicArgumentIds_[i];
            this.moveInputBefore(id, afterArg);
            this.moveInputBefore(afterArg, id);
          }
        }
      };

      blockDefinition.populateArgument_ = function (type, connectionMap, id, input, i) {
        let oldBlock = null;
        let oldShadow = null;
        if (connectionMap && id in connectionMap) {
          const saveInfo = connectionMap[id];
          oldBlock = saveInfo.block;
          oldShadow = saveInfo.shadow;
        }

        const getDefaultValue = (id, i) => {
          const { defaultValues } = this.dynamicArgInfo_;
          const type = typeof defaultValues;
          if (type === 'function') return defaultValues(i, id);
          if (Array.isArray(defaultValues)) {
            const len = defaultValues.length;
            if (i < len - 1) return defaultValues[i];
            if (i === len - 1) return defaultValues[len - 1];
            return `${defaultValues[len - 1]}${i - len + 2}`;
          }
          return defaultValues;
        };

        if (connectionMap && oldBlock) {
          connectionMap[input.name] = null;
          oldBlock.outputConnection.connect(input.connection);
          if (type !== 'b') {
            const shadowDom = oldShadow || this.buildShadowDom_(type);
            input.connection.setShadowDom(shadowDom);
          }
        } else {
          this.attachShadow_(input, type, getDefaultValue(id, i));
        }
      };

      blockDefinition.deleteShadows_ = Blockly.ScratchBlocks.ProcedureUtils.deleteShadows_;
      blockDefinition.buildShadowDom_ = Blockly.ScratchBlocks.ProcedureUtils.buildShadowDom_;
    }

    const patchSymbol = Symbol('patch');

    function initExpandableBlocks(extension, plusImage = rightArrow, minusImage = leftArrow) {
      const { runtime } = extension;
      if (runtime.isPlayerOnly) return;

      const Blockly = getScratchBlocks(runtime);
      const { PlusSelectButton, PlusButton, MinusButton } = createButtons(Blockly, plusImage, minusImage);
      proxyBlocklyBlocksObject(runtime);

      if (extension[patchSymbol]) return;
      extension[patchSymbol] = true;
      const origGetInfo = extension.getInfo;
      extension.getInfo = function () {
        const info = origGetInfo.call(this);
        const { id, blocks: blocksInfo } = info;
        extInfo[id] = { id, PlusSelectButton, PlusButton, MinusButton };
        blocksInfo.forEach((i) => {
          const { dynamicArgsInfo } = i;
          if (dynamicArgsInfo) {
            dynamicArgsInfo.dynamicArgTypes = dynamicArgsInfo.dynamicArgTypes || ['s'];
            dynamicArgsInfo.extInfo = extInfo[id];
            enabledDynamicArgBlocksInfo[`${id}_${i.opcode}`] = dynamicArgsInfo;
          }
        });
        return info;
      };
    }

    function getDynamicArgs(args) {
      const res = [];
      for (let i = 1; ; i++) {
        const v = args[`DYNAMIC_ARGS${i}`];
        if (v === undefined) return res;
        res.push(v);
      }
    }

    return { initExpandableBlocks, getDynamicArgs };
  })();

  // --- It's all prefixes up here --- qwq

  class CyberexplorerToolboxWithDynamicJoin {
    constructor(runtime) {
      this.runtime = runtime;
      this.databases = {};
      this.dbName = DB_NAME;
      initExpandableBlocks(this);
    }

    getInfo() {
      return {
        id: "cyberexplorertoolbox",
        name: Scratch.translate("Cyberexplorer's Toolbox"),
        color1: "#2196F3",
        color2: "#1976D2",
        color3: "#1565C0",
        blocks: [
          {
            blockType: "label",
            text: Scratch.translate("IndexedDB"),
          },
          {
            opcode: "setDatabaseName",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("Set the database name to [databaseName]"),
            arguments: {
              databaseName: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "MyDatabase"
              }
            }
          },
          {
            opcode: "getValue",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("get value of [key]"),
            arguments: {
              key: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i"
              }
            }
          },
          {
            opcode: "storeValue",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("store [key] as [value]"),
            arguments: {
              key: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i"
              },
              value: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "1145"
              }
            }
          },
          {
            opcode: "getNthKeyValuePair",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("get [part] of the nth key-value pair [n]"),
            arguments: {
              part: {
                type: Scratch.ArgumentType.STRING,
                menu: "partOptions",
                defaultValue: "key"
              },
              n: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1
              }
            }
          },
          {
            opcode: "setProjectDescription",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("set project description to [description]"),
            arguments: {
              description: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "This is a Scratch project"
              }
            }
          },
          {
            opcode: "deleteKey",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("delete key [key]"),
            arguments: {
              key: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i"
              }
            }
          },
          "---",
          
          {
            opcode: "getCurrentDatabaseName",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("Get current database name")
          },
          {
            opcode: "getCurrentDatabaseSize",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("Get current database size")
          },
          {
            opcode: "getProjectDescription",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("project description")
          },
          {
            opcode: "getAllKeyValuePairs",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("Get all key-value pairs")
          },
          {
            opcode: "getNumberOfKeys",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("get number of keys")
          },
          {
            opcode: "checkIfDatabaseExists",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("Is database [databaseName] exists"),
            arguments: {
              databaseName: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "MyDatabase"
              }
            }
          },
          {
            opcode: "createNewDatabase",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("Create new database [databaseName]"),
            arguments: {
              databaseName: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "NewDatabase"
              }
            }
          },
          {
            opcode: "deleteDatabase",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("Delete database [databaseName]"),
            arguments: {
              databaseName: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "MyDatabase"
              }
            }
          },
          {
            opcode: "clearStorage",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("clear storage")
          },
          "---",

          {
            blockType: "label",
            text: Scratch.translate("Operation"),
          },
          {
            opcode: "ternaryOperator",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("[CONDITION]?[THEN]:[ELSE]"),
            arguments: {
              CONDITION: {
                type: Scratch.ArgumentType.BOOLEAN,
              },
              THEN: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "114"
              },
              ELSE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "514"
              },
            },
          },
          {
            opcode: "fetchTextFromURL",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("get [URL] "),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "https://extensions.turbowarp.org/hello.txt",
              },
            },
          },
          {
            opcode: "openFileOfType",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("Opens the file of [TYPE] and returns as [CONTENT_TYPE]"),
            arguments: {
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "*",
              },
              CONTENT_TYPE: {
                type: Scratch.ArgumentType.MENU,
                menu: "contentType",
              },
            },
          },
          "---",

          
          {
            opcode: "joinStrings",
            blockType: BlockType.REPORTER,
            text: Scratch.translate("join strings"),
            disableMonitor: true,
            dynamicArgsInfo: {
              defaultValues: ["Input 1", "Input 2"],
              joinCh: (i) => (i === 0 ? "" : ""),
            },
          },
          {
            opcode: "addNumbers",
            blockType: BlockType.REPORTER,
            text: Scratch.translate("add"),
            disableMonitor: true,
            dynamicArgsInfo: {
              defaultValues: [1, 2],
              joinCh: (i) => (i === 0 ? "" : "+"),
            },
          },
          {
            opcode: "subtractNumbers",
            blockType: BlockType.REPORTER,
            text: Scratch.translate("subtract"),
            disableMonitor: true,
            dynamicArgsInfo: {
              defaultValues: [10, 5],
              joinCh: (i) => (i === 0 ? "" : "-"),
            },
          },
          {
            opcode: "multiplyNumbers",
            blockType: BlockType.REPORTER,
            text: Scratch.translate("multiply"),
            disableMonitor: true,
            dynamicArgsInfo: {
              defaultValues: [3, 4],
              joinCh: (i) => (i === 0 ? "" : "*"),
            },
          },
          {
            opcode: "divideNumbers",
            blockType: BlockType.REPORTER,
            text: Scratch.translate("divide"),
            disableMonitor: true,
            dynamicArgsInfo: {
              defaultValues: [20, 5],
              joinCh: (i) => (i === 0 ? "" : "÷"),
            },
          },
          "---",

          {
            blockType: "label",
            text: Scratch.translate("Color dependent"),
          },
          {
            opcode: "hexToColor",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("convert hex color [HEX] to [FORMAT]"),
            arguments: {
              HEX: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "#66CCFF",
              },
              FORMAT: {
                type: Scratch.ArgumentType.STRING,
                menu: "FORMAT_OPTIONS",
                defaultValue: "HSV",
              },
            },
          },
          {
            opcode: "hsvToColor",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("convert HSV [HUE] [SAT] [VAL] to [FORMAT]"),
            arguments: {
              HUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 200,
              },
              SAT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 60,
              },
              VAL: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 100,
              },
              FORMAT: {
                type: Scratch.ArgumentType.STRING,
                menu: "FORMAT_OPTIONS",
                defaultValue: "RGB",
              },
            },
          },
          {
            opcode: "rgbToColor",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("convert RGB [R] [G] [B] to [FORMAT]"),
            arguments: {
              R: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 102,
              },
              G: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 204,
              },
              B: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 255,
              },
              FORMAT: {
                type: Scratch.ArgumentType.STRING,
                menu: "FORMAT_OPTIONS",
                defaultValue: "HSV",
              },
            },
          },
          "---",

          {
            blockType: "label",
            text: Scratch.translate("Alert dependent"),
          },
          {
            opcode: "showAlert",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("show alert [TEXT]"),
            arguments: {
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("Hello, World!")
              }
            }
          },
          {
            opcode: "confirmMessage",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("confirm [TEXT]"),
            arguments: {
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Are you OK?"
              }
            }
          },
          {
            opcode: "promptMessage",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("prompt [TEXT]"),
            arguments: {
              TEXT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("What is your name?")
              }
            }
          },

          //add new blocks

        ],
        menus: {
          partOptions: {
            items: [
              { text: Scratch.translate("key"), value: "key" },
              { text: Scratch.translate("value"), value: "value" }
            ]
          },
          contentType: {
            items: [
              { text: Scratch.translate("text"), value: "text" },
              { text: Scratch.translate("binary text"), value: "binary" },
              { text: Scratch.translate("DataURL"), value: "dataURL" }
            ]
          },
          FORMAT_OPTIONS: {
            items: [
              { text: Scratch.translate("HSV"), value: "HSV" },
              { text: Scratch.translate("RGB"), value: "RGB" },
              { text: Scratch.translate("Hexadecimal"), value: "Hexadecimal" }
            ]
          }
        }
      };
    }

    async setDatabaseName(args) {
      this.dbName = args.databaseName;
    }

    async getCurrentDatabaseName() {
      return this.dbName;
    }

    async getCurrentDatabaseSize() {
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.count();
        request.onsuccess = () => {
          const estimatedSizeBytes = request.result * 100;
          const estimatedSizeKB = (estimatedSizeBytes / 1024).toFixed(2);
          resolve(estimatedSizeKB);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async checkIfDatabaseExists(args) {
      const dbName = args.databaseName;
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onerror = () => resolve(false);
        request.onsuccess = () => resolve(true);
        request.onupgradeneeded = () => resolve(false);
      });
    }

    async getProjectDescription() {
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.get("projectDescription");
        request.onsuccess = () => {
          if (request.result) {
            resolve(request.result.description);
          } else {
            resolve(Scratch.translate(""));
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    async createNewDatabase(args) {
      const dbName = args.databaseName;
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = () => resolve();
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: "key" });
          }
        };
      });
    }

    async deleteDatabase(args) {
      const dbName = args.databaseName;
      return new Promise((resolve, reject) => {
        const request = indexedDB.deleteDatabase(dbName);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = () => resolve();
      });
    }

    async getAllKeyValuePairs() {
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.getAll();
        request.onsuccess = () => {
          const result = {};
          request.result.forEach(item => {
            result[item.key] = item.value;
          });
          resolve(JSON.stringify(result, null, 2));
        };
        request.onerror = () => reject(request.error);
      });
    }

    async _openDB(databaseName = DB_NAME) {
      if (this.databases[databaseName]) {
        return this.databases[databaseName];
      }

      return new Promise((resolve, reject) => {
        const request = indexedDB.open(databaseName, DB_VERSION);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = (event) => {
          this.databases[databaseName] = event.target.result;
          resolve(event.target.result);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: "key" });
          }
        };
      });
    }

    async storeValue(args) {
      const { key, value } = args;
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.put({ key, value });
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async setProjectDescription(args) {
      const { description } = args;
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.put({ key: "projectDescription", description });
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async getValue(args) {
      const { key } = args;
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.get(key);
        request.onsuccess = () => {
          if (request.result) {
            resolve(request.result.value);
          } else {
            resolve(Scratch.translate(""));
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    async deleteKey(args) {
      const { key } = args;
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.delete(key);
        request.onsuccess = () => {
          console.log(Scratch.translate("Key [key] deleted", { key }));
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }

    async getNumberOfKeys() {
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.count();
        request.onsuccess = () => {
          resolve(request.result);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async getNthKeyValuePair(args) {
      const { part, n } = args;
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.openCursor();
        let count = 0;
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            count += 1;
            if (count === n) {
              if (part === "key") {
                resolve(cursor.key);
              } else if (part === "value") {
                resolve(cursor.value.value);
              }
              return;
            }
            cursor.continue();
          } else {
            resolve("");
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    async clearStorage() {
      const db = await this._openDB();
      const transaction = db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      return new Promise((resolve, reject) => {
        const request = store.clear();
        request.onsuccess = () => {
          console.log(Scratch.translate("Storage cleared"));
          resolve();
        };
        request.onerror = () => reject(request.error);
      });
    }

    ternaryOperator(args) {
      return args.CONDITION ? args.THEN : args.ELSE;
    }

    async fetchTextFromURL(args) {
      const url = args.URL;
      try {
        const response = await fetch(url);
        const data = await response.text();
        return data;
      } catch (error) {
        console.error("获取文本时出错:", error);
        return "";
      }
    }

    async openFileOfType(args) {
      const type = args.TYPE;
      const contentType = args.CONTENT_TYPE;
      const input = document.createElement("input");
      input.type = "file";
      input.style.display = "none";
      input.accept = type !== "*" ? type : "";
      input.click();
      return new Promise((resolve, reject) => {
        input.onchange = (event) => {
          const file = event.target.files[0];
          if (!file) {
            reject("没有选择文件。");
            return;
          }
          let content;
          const reader = new FileReader();
          switch (contentType) {
            case "text":
              reader.readAsText(file);
              reader.onload = () => {
                content = reader.result;
                resolve(createJsonResponse(file.name, content, type));
              };
              reader.onerror = () => {
                reject("读取文件时出错。");
              };
              break;
            case "binary":
              reader.readAsBinaryString(file);
              reader.onload = () => {
                content = reader.result;
                resolve(createJsonResponse(file.name, content, type));
              };
              reader.onerror = () => {
                reject("读取文件时出错。");
              };
              break;
            case "dataURL":
              reader.readAsDataURL(file);
              reader.onload = () => {
                content = reader.result;
                resolve(createJsonResponse(file.name, content, type));
              };
              reader.onerror = () => {
                reject("读取文件时出错。");
              };
              break;
            default:
              reject("不支持的内容类型。");
          }
        };
      });
    }

    hexToColor(args) {
      const hex = args.HEX.trim();
      const format = args.FORMAT;
      if (!hex.startsWith("#") || hex.length !== 7) {
        return Scratch.translate("");
      }
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      if (format === "RGB") {
        const rgbRounded = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        return JSON.stringify(rgbRounded);
      }
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;
      let hue = 0;
      if (delta !== 0) {
        switch (max) {
          case r:
            hue = ((g - b) / delta) % 6;
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue *= 60;
        if (hue < 0) hue += 360;
      }
      const saturation = max === 0 ? 0 : delta / max;
      const value = max;
      const hueRounded = Math.round(hue);
      const saturationPercentage = Math.round(saturation * 100);
      const valuePercentage = Math.round(value * 100);
      if (format === "HSV") {
        return JSON.stringify([hueRounded, saturationPercentage, valuePercentage]);
      } else if (format === "Hexadecimal") {
        const hexR = Math.round(r * 255).toString(16).padStart(2, "0");
        const hexG = Math.round(g * 255).toString(16).padStart(2, "0");
        const hexB = Math.round(b * 255).toString(16).padStart(2, "0");
        return `#${hexR}${hexG}${hexB}`;
      }
    }

    hsvToColor(args) {
      const hue = args.HUE;
      const saturation = args.SAT;
      const value = args.VAL;
      const format = args.FORMAT;
      if (
        isNaN(hue) || hue < 0 || hue > 360 ||
        isNaN(saturation) || saturation < 0 || saturation > 100 ||
        isNaN(value) || value < 0 || value > 100
      ) {
        return Scratch.translate("");
      }
      const saturationNormalized = saturation / 100;
      const valueNormalized = value / 100;
      let chroma = valueNormalized * saturationNormalized;
      let huePrime = hue / 60;
      let x = chroma * (1 - Math.abs((huePrime % 2) - 1));
      let m = valueNormalized - chroma;
      let rPrime, gPrime, bPrime;
      if (huePrime >= 0 && huePrime < 1) {
        [rPrime, gPrime, bPrime] = [chroma, x, 0];
      } else if (huePrime >= 1 && huePrime < 2) {
        [rPrime, gPrime, bPrime] = [x, chroma, 0];
      } else if (huePrime >= 2 && huePrime < 3) {
        [rPrime, gPrime, bPrime] = [0, chroma, x];
      } else if (huePrime >= 3 && huePrime < 4) {
        [rPrime, gPrime, bPrime] = [0, x, chroma];
      } else if (huePrime >= 4 && huePrime < 5) {
        [rPrime, gPrime, bPrime] = [x, 0, chroma];
      } else if (huePrime >= 5 && huePrime < 6) {
        [rPrime, gPrime, bPrime] = [chroma, 0, x];
      } else {
        [rPrime, gPrime, bPrime] = [0, 0, 0];
      }
      const r = Math.round((rPrime + m) * 255);
      const g = Math.round((gPrime + m) * 255);
      const b = Math.round((bPrime + m) * 255);
      if (format === "RGB") {
        return JSON.stringify([r, g, b]);
      } else if (format === "Hexadecimal") {
        const hex = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
        return hex;
      } else return "";
    }

    rgbToColor(args) {
      const r = args.R / 255;
      const g = args.G / 255;
      const b = args.B / 255;
      const format = args.FORMAT;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;
      let hue = 0;
      if (delta !== 0) {
        switch (max) {
          case r:
            hue = ((g - b) / delta) % 6;
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue *= 60;
        if (hue < 0) hue += 360;
      }
      const saturation = max === 0 ? 0 : delta / max;
      const value = max;
      const hueRounded = Math.round(hue);
      const saturationPercentage = Math.round(saturation * 100);
      const valuePercentage = Math.round(value * 100);
      if (format === "HSV") {
        return JSON.stringify([hueRounded, saturationPercentage, valuePercentage]);
      } else if (format === "Hexadecimal") {
        const hexR = Math.round(r * 255).toString(16).padStart(2, "0");
        const hexG = Math.round(g * 255).toString(16).padStart(2, "0");
        const hexB = Math.round(b * 255).toString(16).padStart(2, "0");
        return `#${hexR}${hexG}${hexB}`;
      } else return "";
    }

    showAlert(args) {
      alert(args.TEXT);
    }

    confirmMessage(args) {
      return confirm(args.TEXT);
    }

    promptMessage(args) {
      const userInput = prompt(args.TEXT);
      return userInput === null ? null : userInput;
    }

    joinStrings(args) {
      const dynamicArgs = getDynamicArgs(args);
      return dynamicArgs.join("");
    }

    addNumbers(args) {
      const dynamicArgs = getDynamicArgs(args);
      return dynamicArgs.reduce((a, b) => Number(a) + Number(b), 0);
    }

    subtractNumbers(args) {
      const dynamicArgs = getDynamicArgs(args);
      return dynamicArgs.reduce((a, b) => Number(a) - Number(b));
    }

    multiplyNumbers(args) {
      const dynamicArgs = getDynamicArgs(args);
      return dynamicArgs.reduce((a, b) => Number(a) * Number(b), 1);
    }

    divideNumbers(args) {
      const dynamicArgs = getDynamicArgs(args);
      return dynamicArgs.reduce((a, b) => Number(a) / Number(b));
    }
  }

  Scratch.extensions.register(new CyberexplorerToolbox(Scratch.vm.runtime));
})(Scratch);
